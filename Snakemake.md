# Workflow bioinformatic

## Snakemake

The [Snakemake](https://snakemake.readthedocs.io/en/stable/) workflow management system is a tool to create **reproducible and scalable** data analyses. Workflows are described via a human readable, Python based language. They can be seamlessly scaled to server, cluster, grid and cloud environments, without the need to modify the workflow definition. Finally, Snakemake workflows can entail a description of required software, which will be automatically deployed to any execution environment.

Alternatives: 
 - [nextflow](https://www.nextflow.io/)
 - Common workflow language and it's implementations : [CWL](https://www.commonwl.org/#Implementations)

### Principle

The user define :

-   a set of rules, which are scripts/command line, encapsuled in a way snakemake can make sense of.
-   an expected results : a file or a list of files
-   a list of file requirements
-   an amount of ressources : number of cpu, memory

Snakemake then devise the succession of rules (script/command) needed to generate the output. If the results cannot be generated from the rules inputed and the files already present in the execution folder, snakemake will let you know and fail.

Snakemake will schedule rules excution optimising ressources allocations (threads/memory/custom ressource).

### Features

-   It is possible to write and use python code inside snakemake
-   snakemake keep track of all files, input input in your workflow. If the input of a rule has been updated, snakemake will rerun all depending rules.
-   snakemake keep track of completion of tasks and can deal with unplanned interuption.
-   snakemake can be easily deployed to clusters without changing any code
-   It is possible to specify ad hoc environment for each step of the pipeline and have each step executed in it's own environment

## Hello world
The minimum rule is :

-   an input
-   an output
-   a shell command/or python code

Example :
```bash
rule Hello_world:
    input: "/home/ubuntu/requirerement.txt"
    output: "/home/ubuntu/snakemake.txt"
    shell: "echo HELLO WORLD > {output}"
```

Write that command in a file for instance with nano.
```bash
mkdir -p ~/Projects/AD_snakemake
cd ~/Projects/AD_snakemake
nano hello.snake
```
**Debuging:**
	- don't forget the colons
	- don't forget the indentations


Then ask snakemake to generate that file:
```bash
snakemake -s hello.snake ~/snakemake.txt --cores 1
```
<details><summary>What happens? </summary>
<p>
	
By specifying a results, for instance ~/snakemake.txt, snakemake will look at all available rules in your snakemake file (hello.snake) and look for any a  output matching your requirement. It check then for correponding required input. If the input is there, only 1 rule need to be run, if it is not, then snakemake look for another rule to generate that output and if it doesn't exist, it will stop.

</p>
</details>

Let's create an empty file 
```bash
touch ~/requirerement.txt
```
Now try again with the previous snakemake command.

###  Wildcards
 Wildcards are keywords between {} used to make rule more general and applicable to multiple situations.
Here we could apply it to make it possible to create a file anywhere on the vm:

```bash
rule Hello_world:
    input: "~/requirerement.txt"
    output: "{path}/snakemake.txt"
    shell: "echo HELLO WORLD > {output}"
```
Let's try this new version:

```bash
snakemake -s hello.snake ~/Data/snakemake.txt --cores 1
``` 
### Additional rule entries
-   threads : number of threads the rule needs, default = 1
-   log file
-   params : additional parameters
-   singularity/conda : specify rule specific environment
-   report : report automatically generated by snakemake
-   message : message printed during execution
-   priority : allows to encourage execution of certain task before others
-  conda: path to a conda env yaml file, to specify a conda env in which the rule will be executed 

Example:
```bash
rule Hello_world:
    input: "~/requirerement.txt"
    output: "{path}/snakemake.txt"
    threads: 100
    log: "{path}/log_hello.txt"
    message: "generating a hello world message"
    shell: "echo HELLO WORLD > {output} 2>{log}"
```
What does happen if threads is bigger than available cores on the vm? 

## Hand on snakemake
### initial bash script
Looking at [this](https://github.com/Sebastien-Raguideau/strain_resolution_practical/blob/main/bash_script.sh) bash script, we are going to use snakemake and translate it into a working pipeline.

### desiging a rule

For a set task, identify files you want snakemake to keep track of

- as input: files you absolutely need to have before starting the task
- as output: files you will need for other rules/ files you want snakemake to check for completion/files you may want to ask snakemake to generate.

If you ever want to use wildcards be sure that all wildcards in input cat be derived from wildcards in output. Snakemake need to be able to identify input from looking at ouput.

### Assembly

Let's start with the creation of files for megahit. The best way to proceed is to copy and paste previous command lines and build around it. First let's have a go at creating the R1.csv and R2.csv.
Start from 
```bash
ls /home/ubuntu/Data/AD_small/*/*R1.fastq | tr "\n" "," | sed 's/,$//' > R1.csv
ls /home/ubuntu/Data/AD_small/*/*R2.fastq | tr "\n" "," | sed 's/,$//' > R2.csv
```
Let's all agree on working on a file called: "binning.snake"
<details><summary>Try for yourself for 5 min before looking here. </summary>
<p>

```bash
rule create megahit_files:
    output: R1 = "{path}/R1.csv",
            R2 = "{path}/R2.csv"
    params: data = "/home/ubuntu/Data/AD_small"
    shell:"""
        ls {params.data}/*/*R1.fastq | tr "\n" "," | sed 's/,$//' > {output.R1}
        ls {params.data}/*/*R2.fastq | tr "\n" "," | sed 's/,$//' > {output.R2}
         """
```	

To note:  
 - I lied to you. The Input keyword is not always needed. I there is no input keyword, the rule can be run unconditionally. 
 - If there are multiple output, I can name them and refers to them in this way in the shell command line.
 - I use params to store the path info, it makes things clearer. 
 - I don't need to place the R1.csv to any particular place, snakemake will guess what {path} needs to be from when it will need to generate that file

</p>
</details>

#### Megahit
Let's do the same with megahit.
Please translate that command line:
```bash
megahit -1 $(<R1.csv) -2 $(<R2.csv) -t 4 -o Assembly
```

<details><summary>Try for yourself for 5 min before looking here. </summary>
<p>

```bash

rule megahit:
    input: R1 = "{path}/R1.csv",
           R2 = "{path}/R2.csv"
    output: "{path}/Assembly/final.contigs.fa"
    params: "{path}/Assembly"
    threads: 4
    shell: "rm -r {params} && megahit -1 $(<{input.R1}) -2 $(<{input.R1}) -t {threads} -o {params}"
```

To note

-  wildcards defined in input output can also be used in the params
- If there is multiple input you can name them and refers to them.
- snakemake will create himself the directory Assembly, this is a problem as megahit throws an error when the directory already exist.
- we specify the number of threads for megahit
</p>
</details>

#### Read mapping
Same as before please translate the following:
```bash
bwa index final.contigs.fa
bwa mem -t 4 Assembly/final.contigs.fa $file $file2 | samtools view -b -F 4 - | samtools sort - > ${stub}.mapped.sorted.bam
```
<details><summary>Clue: do not write loop, try to write it for a unique sample. Snakemake will loop for you.</summary>
<p>

```bash
rule index_assembly:
    input: "{path}/final.contigs.fa"
    output: "{path}/index.done"
    shell:"""
          bwa index {input}
          touch {output}
          """
```
To note:

- here we use a bogus file for snakemake to track completion of index, if file exist, snakemake know index is done: you don't always need to let snakemake keep track of all your files.

```bash
rule map_reads:
    input: R1 = "/home/ubuntu/Data/AD_small/{sample}/{sample}_R1.fastq",
           R2 = "/home/ubuntu/Data/AD_small/{sample}/{sample}_R1.fastq",
           index = "{path}/Assembly/index.done",
           assembly = "{path}/Assembly/final.contigs.fa"
    output: "{path}/Map/{sample}.mapped.sorted.bam"
    threads: 4
    shell: "bwa mem -t {threads} {input.assembly} {input.R1} {input.R2} | samtools view -b -F 4 - | samtools sort - > {output}"

```
To note:

- there are way to use python in snakemake to reduce the length of input.R1. Asks if you are not already confused by everything else :)
- here we have 2 wildcards at the same time, sample and path. The critical part is for both to be present in output. If they are in input but not output, snakemake can't replace them.
- this rule will be called once per sample, you can chose to use threads: 4, in this case only 1 map_reads task will be run at the time, or you can use threads: 1, and in this case there will be no parallelisation with bwa.

</p>
</details>

### Sanity check
Have a try at running current snakemake. 
Let's generate 1 sample .bam file

```bash
snakemake -s binning.snake ~/Projects/AD_snakemake/Map/sample1.mapped.sorted.bam --cores 4 --dry-run
```
If you are not under attack of multiple errors message, snakemake will have listed the series of task it plans to execute. That is the point of the "dry-run" option.

Please add the errors messages you observe on slack so we can try to explain what they mean.

<details><summary>If you are late, or you can't debug your snakemake </summary>
<p>
Use the file stored at:

    ~/repos/strain_resolution_practical/binning.snake

</p>
</details>

### Coverage
The next command line is a bit troublesome to translate into snakemake since we will need some python coding skill.
```bash
jgi_summarize_bam_contig_depths --outputDepth depth.txt *.bam
```
We need to list all .bam file, one for each sample as input. First let's list all sample name with a python one-liner. Please copy these lines in the binning.snake file. 


```python
# import functions from basic python library
import glob 
from os.path import basename,dirname

# create a string variable to store path
DATA="/home/ubuntu/Data/AD_small"
# use the glob function to find all R1.fastq file in each folder of DATA
# then only keep the directory name wich is also the sample name
SAMPLES = [basename(dirname(file)) for file in glob.glob("%s/*/*_R1.fastq"%DATA)]
```
This create a list named SAMPLES, containing the name of each sample. 
We create the snakemake rule:

```bash
rule generate_coverage:
	input: expand("{{path}}/Map/{sample}.mapped.sorted.bam",sample=SAMPLES)
	output: "{path}/Binning/depth.txt"
	shell: "jgi_summarize_bam_contig_depths --outputDepth {output} {input}"
```
To note:

- we use the function expand, it allows to create a list of element. Here {sample} will be replaced by element of SAMPLES. We need to use double {{}} on path, so that expand doesn't try to replace it.
- you may want to use bash pattern matching here as in *.bam, but that won't work. Snakemake run that command before any task is run and before any .bam exist. Thus no bam file will be detected

### Binning
This one is comparatively easy to translate and use tricks we've went through before, try having a go:
```bash
metabat2 -i Assembly/final.contigs.fa -a Binning/depth.txt -t 4 -o Binning/Bins/Bin
```

<details><summary>solution </summary>
<p>

```bash
rule metabat2:
    input: asmbl = "{path}/Assembly/final.contigs.fa",
           cov = "{path}/Binning/depth.txt"
    params: "{path}/Binning/Bins/bin"
    output: "{path}/Binning/metabat2.done"
    threads: 4
    shell: """
    metabat2 -i {input.asmbl} -a {input.cov} -t {threads} -o {params}
    touch {output}
    """
```
</p>
</details>

### Missing dependencies
If you try to launch this snakemake as is, it will works. That is the set of tasks to run will be clearly elucidated and snakemake will start executing them. 
However if you check quickly you will see that we are missing 1 important programs which is megahit. 
We can either install it with conda/mamba or ... we could have a go at using snakemake to do so. 
You just need a path to a conda env file which specify the "dependencies" needed as well as to which "channel" it is stored on. I prepared that file [here](https://github.com/Sebastien-Raguideau/strain_resolution_practical/blob/main/conda_env.yaml).
```bash
rule megahit:
    input: R1 = "{path}/R1.csv",
           R2 = "{path}/R2.csv"
    output: "{path}/Assembly/final.contigs.fa"
    params: "{path}/Assembly"
    conda: "/home/ubuntu/repos/strain_resolution_practical/conda_env.yaml"
    threads: 50
    shell: "rm -r {params} && megahit -1 $(<{input.R1}) -2 $(<{input.R1}) -t {threads} -o {params}"
```
Then you need to launch snakemake with the option `--use-conda`

    snakemake -s binning.snake ~/Projects/AD_snakemake/Map/sample1.mapped.sorted.bam --cores 4 --use-conda

Snakemake will start by creating the corresponding env.

### To go further/summary

-   Snakemake works in reverse, it starts from the specified output and looks for rules/recipes able to generate it. It tries also multiple wildcards values until it find a way to generate the output.
-   As a snakemake grow bigger, ambiguity in rules may pop up : 2 rules with the same output. And thus, 2 rules/recipe to create the same input. To solve this issue, you need to restrict your rules making them less universal, either a specific path (prodigal/{genome.gff}), or a specific filename [genome}_prodigal.gff. You can also constrain wildcards or specify a priority of rules.
-   Snakemake only keep track of files specified in "input" and "output". A bad way to do snakemake is to have rules generating untracked files and just outputing a flag.

-   Snakemake will resolve the sequence of rules execution before starting --> if you don't know beforehand the number of files generated, it makes things more complicated. You can: 
	- Split your snakemake in multiple independant pipeline, so that at the start of the subsequent snakemake the first one is done and the number of file is known.
	- Use a more complex snakemake concept: checkpoints. 
	- Stop using snakemake to monitors theses files. Don't refers to them explicitly in input/output. Instead create emtpy "flag" at the end of a rule execution and have snakemake take that as input/output. You loose however restarts/incomplete perks of snakemake and flag file do not mesh well with restart/touch mechanisms.
- When your number of tasks increase over 10000 snakemake slows down from the sheer quantity of files/tasks to keep track of. In these case, it is better to use a hierachical approach: snakemake calling a snakemake or using gnu parallel to call multiple snakemakes. 

